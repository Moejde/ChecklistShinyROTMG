<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ROTMG — Itens & Config (Checklist por Object type)</title>
  <style>
    :root{
      --bg:#0b0f14; --card:#0f172a; --border:#1f2937; --text:#e5e7eb; --muted:#93a0ad;
      --chip:#172136; --chip-br:#24324a; --accent:#60a5fa;
      --panel:#0b1322; --gap:8px; --cols:5; --tile:160px; /* tamanho do tile em px (ajustado via JS) */
    }
    *{box-sizing:border-box} html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--text);font:14px/1.45 system-ui,Segoe UI,Roboto,Arial}

    header{position:sticky;top:0;z-index:5;background:linear-gradient(180deg,rgba(15,23,42,.9),rgba(15,23,42,.7));backdrop-filter:blur(6px);border-bottom:1px solid var(--border)}
    .container{max-width:1200px;margin:0 auto;padding:14px 16px}
    h1{margin:0;font-size:16px;font-weight:700;letter-spacing:.2px}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;justify-content:space-between}
    .tabs{display:flex;gap:6px;align-items:center}
    .tab{border:1px solid var(--border);background:#0c1423;color:var(--muted);padding:8px 12px;border-radius:12px;cursor:pointer}
    .tab.active{color:var(--text);border-color:#2e3a55;background:#14203b}
    .tab:hover{border-color:#34425f}
    .btn{border:1px solid var(--border);background:#0c1423;color:var(--text);padding:8px 12px;border-radius:12px;cursor:pointer}
    .btn:hover{border-color:#3a4a6a}
    select.btn{padding-right:28px}
    input[type="file"]{color:var(--text);background:#0a1322;border:1px solid var(--border);padding:8px 10px;border-radius:10px}
    .muted{color:var(--muted)}
    .hidden{display:none !important}
    .grid{display:grid;gap:12px}
    .grid-2{grid-template-columns:repeat(auto-fit,minmax(320px,1fr))}
    .grid-4{grid-template-columns:repeat(auto-fit,minmax(180px,1fr))}
    .card{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:14px;box-shadow:0 1px 0 rgba(0,0,0,.2)}
    main{padding:16px 16px 24px}

    /* Galeria (aba Itens) */
    .gallery{display:grid;gap:var(--gap);grid-template-columns:repeat(var(--cols), minmax(0,1fr));align-items:stretch}
    .tile{display:flex;flex-direction:column;gap:4px}
    .thumb{
      position:relative;background:#0c1423;border:1px solid var(--border);border-radius:10px;
      display:flex;align-items:center;justify-content:center;
      padding:2px;aspect-ratio:1/1;overflow:hidden;cursor:pointer;
      transition:border-color .15s,box-shadow .15s,background-color .15s
    }
    .thumb img{
      position:relative; z-index:1; /* abaixo do ícone */
      width:100%;height:100%;object-fit:contain;
      image-rendering:pixelated;image-rendering:-moz-crisp-edges;image-rendering:crisp-edges;
      filter:drop-shadow(0 1px 2px rgba(0,0,0,.35));
    }
    .restore-overlay{
      position:absolute;
      inset:0;
      border-radius:10px;
      background:linear-gradient(135deg, rgba(30,64,175,.65), rgba(79,70,229,.55));
      display:flex;
      align-items:center;
      justify-content:center;
      opacity:0;
      transition:opacity .18s ease;
      pointer-events:none;
      z-index:2;
    }
    .restore-icon{
      font-size:24px;
      color:#e0ecff;
      text-shadow:0 2px 6px rgba(0,0,0,.4);
    }
    #removedGallery .tile:hover .restore-overlay{ opacity:.9; }
    .thumb:hover{border-color:#40527a}

    /* Ícone (i) — sobre a imagem, responsivo e só no hover/foco */
    .info-btn{
      position:absolute;
      top:clamp(4px, calc(var(--tile)*0.04), 8px);
      right:clamp(4px, calc(var(--tile)*0.04), 8px);
      width:clamp(14px, calc(var(--tile)*0.14), 26px);
      height:clamp(14px, calc(var(--tile)*0.14), 26px);
      border-radius:999px;
      display:flex; align-items:center; justify-content:center;
      font-weight:700;
      font-size:clamp(10px, calc(var(--tile)*0.08), 14px);
      text-decoration:none;
      color:#0b0f14; background:#e5e7eb; border:1px solid #111827;
      box-shadow:0 1px 2px rgba(0,0,0,.35);
      z-index:3;
      opacity:0;                   /* escondido por padrão */
      pointer-events:none;         /* não clicável oculto */
      transition:opacity .12s ease;
    }
    .close-btn{
      position:absolute;
      top:50%; left:50%;
      transform:translate(-50%,-50%);
      width:clamp(18px, calc(var(--tile)*0.2), 32px);
      height:clamp(18px, calc(var(--tile)*0.2), 32px);
      border-radius:999px;
      display:flex; align-items:center; justify-content:center;
      font-weight:700;
      font-size:clamp(10px, calc(var(--tile)*0.1), 16px);
      text-decoration:none;
      color:#fff; background:#dc2626; border:1px solid #7f1d1d;
      box-shadow:0 1px 4px rgba(0,0,0,.45);
      z-index:4;
      transition:opacity .12s ease, transform .12s ease;
      cursor:pointer;
      padding:0;
      line-height:1;
      font-family:inherit;
      -webkit-appearance:none;
      appearance:none;
    }
    .thumb .info-btn,
    .thumb .close-btn{ opacity:0; pointer-events:none; }
    .thumb:hover .info-btn,
    .thumb:focus-within .info-btn{ opacity:1; pointer-events:auto; }
    body.delete-mode .thumb:hover .close-btn,
    body.delete-mode .thumb:focus-within .close-btn{ opacity:1; pointer-events:auto; }
    .close-btn:hover{ transform:translate(-50%,-50%) scale(1.05); }
    .info-btn:hover{ filter:brightness(0.95) }

    /* Legenda e ocultação por colunas */
    .tile .cap{font-size:12px;color:var(--muted);text-align:center}
    .hide-captions .tile .cap{display:none}
    #gallery.hide-captions .tile .cap{display:none} /* escopo extra robusto */

    /* Ícone some a partir de 25 colunas */
    .hide-info .info-btn,
    .hide-info .close-btn{ display:none }

    /* Coletado: outline + fundo verde claro */
    .tile.checked .thumb{
      border-color:#00b646;
      box-shadow:0 0 0 2px rgba(73, 209, 125, 0.55);
      background:rgb(36, 114, 49);
    }
    .tile.checked .thumb img{
      opacity:.3;
      filter:saturate(0.4);
    }
    .tile.is-removing{
      visibility:hidden;
    }
    .tile.removing,
    .tile-clone.removing{
      pointer-events:none;
      animation: flyToConfig 1s cubic-bezier(.7,-0.1,.2,1) forwards;
      transform-origin:center center;
      --fly-x: 180px;
      --fly-y: -120px;
    }
    .tile-clone{
      position:fixed !important;
      pointer-events:none !important;
      margin:0 !important;
      z-index:999 !important;
      top:0;
      left:0;
    }
    .tile.shiny .thumb{
      position:relative;
      overflow:hidden;
    }
    .tile.shiny .thumb::before{
      content:"";
      position:absolute;
      inset:0;
      border-radius:10px;
      background:linear-gradient(135deg, rgba(99,102,241,.55), rgba(236,72,153,.55), rgba(45,212,191,.5));
      opacity:.8;
      pointer-events:none;
      z-index:0;
    }
    .tile.white .thumb{
      position:relative;
      overflow:hidden;
    }
    .tile.white .thumb::before{
      content:"";
      position:absolute;
      inset:0;
      border-radius:10px;
      background:linear-gradient(135deg, rgba(215,217,221,.6), rgba(120,121,123,.45));
      opacity: 0.3;;
      pointer-events:none;
      z-index:0;
    }
    @keyframes flyToConfig{
      0%{
        transform:translate3d(0,0,0) scale(1);
        opacity:1;
      }
      40%{
        transform:translate3d(calc(var(--fly-x) * 0.45), calc(var(--fly-y) * 0.45),0) scale(0.88);
        opacity:0.98;
      }
      90%{
        transform:translate3d(calc(var(--fly-x) * 0.98), calc(var(--fly-y) * 0.98),0) scale(0.18);
        opacity:0.85;
      }
      100%{
        transform:translate3d(var(--fly-x), var(--fly-y),0) scale(0);
        opacity:0;
      }
    }

    /* Controles e UI */
    .seg{display:flex;gap:6px;align-items:center;background:#0b1322;border:1px solid var(--border);padding:4px;border-radius:12px}
    .seg .chip{padding:6px 10px;border-radius:10px;border:1px solid transparent;background:transparent;color:var(--muted);cursor:pointer}
    .seg .chip.active{background:#14203b;color:var(--text);border-color:#324567}
    .seg .chip:hover{border-color:#3a4a6a}
    .stats .stat{background:#0c1423;border:1px solid var(--border);border-radius:14px;padding:12px}
    .stat .l{font-size:12px;color:var(--muted)} .stat .v{font-size:18px;font-weight:700}

    .toolsRow{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .progressPanel{display:flex;gap:14px;align-items:center;margin-left:auto;flex-wrap:wrap}
    .pGroup{display:flex;gap:8px;align-items:center}
    .pLabel{font-size:12px;color:var(--muted);min-width:44px;text-align:right}
    .pBar{width:180px;height:10px;border:1px solid var(--border);border-radius:8px;overflow:hidden;background:#101826;box-shadow:inset 0 0 0 1px rgba(0,0,0,.15)}
    .pFill{height:100%;width:0%}
    .pBar.rainbow .pFill{background:linear-gradient(90deg,#ff5f6d,#ffc371,#f9f871,#a0f0a0,#7fd7ff,#9a7fff,#ff7fd1)}
    .pBar.white .pFill{background:linear-gradient(90deg,#ffffff,#dcdcdc)}
    .pText{font-size:12px;color:var(--muted);min-width:64px;text-align:left}

    .colsCtrl{display:flex;align-items:center;gap:8px;margin-left:6px}
    .colsCtrl input[type="range"]{width:200px}
    .caps{font-variant-numeric:tabular-nums}

    /* Busca (itens) */
    .searchInput{
      color:var(--text);
      background:#0a1322;
      border:1px solid var(--border);
      padding:8px 10px;
      border-radius:10px;
      width:220px;
    }
    .searchInput::placeholder{ color:var(--muted) }

    /* Switch 3 posições (Coletados — Neutro — Não coletados) */
    .triCtrl{display:flex;align-items:center;gap:8px;background:#0b1322;border:1px solid var(--border);padding:6px 10px;border-radius:10px}
    .triCtrl .label{color:var(--muted);font-size:12px}
    .triCtrl input[type="range"]{
      appearance:none; -webkit-appearance:none; width:170px; height:12px; border-radius:999px; cursor:pointer;
      background:#25324a;
      background-image:
        linear-gradient(#25324a,#25324a),
        linear-gradient(#3a4a6a,#3a4a6a),
        linear-gradient(#3a4a6a,#3a4a6a);
      background-size:100% 12px,2px 16px,2px 16px;
      background-position:center,33% center,66% center;
      background-repeat:no-repeat;
      border:1px solid var(--border);
    }
    .triCtrl input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none; appearance:none;
      width:18px; height:18px; border-radius:50%;
      background:#e5e7eb; border:2px solid #111827;
      box-shadow:0 1px 2px rgba(0,0,0,.35); margin-top:-3px;
    }
    .triCtrl input[type="range"]::-moz-range-thumb{
      width:18px; height:18px; border-radius:50%;
      background:#e5e7eb; border:2px solid #111827;
      box-shadow:0 1px 2px rgba(0,0,0,.35);
    }
    .triCtrl input[type="range"]::-moz-range-track{
      height:12px; background:#25324a; border:none; border-radius:999px;
    }
    .deleteModeToggle{
      display:flex;
      align-items:center;
      gap:6px;
      background:#0b1322;
      border:1px solid var(--border);
      padding:6px 10px;
      border-radius:10px;
      cursor:pointer;
    }
    .deleteModeToggle input{
      width:16px;
      height:16px;
      accent-color:#dc2626;
      cursor:pointer;
      margin:0;
    }
    .deleteModeToggle .muted{
      font-size:12px;
      user-select:none;
    }
  </style>
</head>
<body>
  <header>
    <div class="container row">
      <h1>ROTMG Whitebag & Shiny Checklist</h1>
      <nav class="tabs">
        <button id="tabItemsBtn" class="tab active">Itens</button>
        <button id="tabConfigBtn" class="tab">Configurações</button>
      </nav>
    </div>
  </header>

  <main class="container">
    <!-- ===== Aba: Itens ===== -->
    <section id="tab-items">
      <div class="card">
        <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;margin-bottom:10px">
          <div id="itemsInfo" class="muted"></div>

          <div class="toolsRow">
            <!-- Filtros -->
            <div class="seg" role="group" aria-label="Filtro de categoria">
              <button id="fltAll"   class="chip active" type="button">Todos</button>
              <button id="fltWhite" class="chip" type="button">White Bag</button>
              <button id="fltShiny" class="chip" type="button">Shiny</button>
            </div>

            <!-- Ordenação -->
            <label class="muted" for="sortMode" style="margin-left:2px">Ordenar:</label>
            <select id="sortMode" class="btn">
              <option value="objectid">A→Z (ObjectId)</option>
              <option value="hex">Hex (Object type)</option>
            </select>
            <button id="sortDirBtn" class="btn" title="Alternar Asc/Desc">Asc</button>

            <!-- Slider de colunas -->
            <div class="colsCtrl" title="Número de colunas visíveis">
              <span class="muted">Colunas:</span>
              <input id="colSlider" class="colSlider" data-label="colLabel" data-marks="colMarks" type="range" min="1" max="10" step="1" value="5" list="colMarks" />
              <datalist id="colMarks"></datalist>
              <span id="colLabel" class="muted caps">5</span>
            </div>

            <!-- Busca por nome -->
            <div class="searchWrap" title="Pesquisar por nome do item">
              <input id="searchBox" class="searchInput" type="search" placeholder="Pesquisar item..." />
            </div>

            <!-- Switch 3 fases -->
            <div class="triCtrl" title="Filtrar por coleta">
              <span class="label">Coletados</span>
              <input id="ownedTri" type="range" min="0" max="2" step="1" value="1" />
              <span class="label">Não coletados</span>
            </div>
            <label class="seg deleteModeToggle" title="Exibir botão vermelho para remover item enquanto estiver ativo">
              <input id="deleteModeToggle" type="checkbox" />
              <span class="muted">Modo exclusão</span>
            </label>

            <!-- Progresso -->
            <div class="progressPanel">
              <div class="pGroup" title="Progresso de Shiny coletados">
                <span class="pLabel">Shiny</span>
                <div class="pBar rainbow"><div id="progShinyFill" class="pFill"></div></div>
                <span id="progShinyText" class="pText">0/0 (0%)</span>
              </div>
              <div class="pGroup" title="Progresso de White Bag coletados">
                <span class="pLabel">White</span>
                <div class="pBar white"><div id="progWhiteFill" class="pFill"></div></div>
                <span id="progWhiteText" class="pText">0/0 (0%)</span>
              </div>
            </div>
          </div>
        </div>

        <div id="gallery" class="gallery"></div>
        <div id="galleryEmpty" class="muted" style="margin-top:10px;display:none"></div>
      </div>
      <div class="muted" style="margin-top:8px">Dica: clique em um item para marcar/desmarcar como coletado. O progresso e salvo automaticamente (arquivo configurado ou navegador).</div>
    </section>

    <!-- ===== Aba: Configurações ===== -->
    <section id="tab-config" class="hidden grid grid-2">
      <section class="card">
        <h3 style="margin:0 0 6px">Fontes de dados</h3>
        <p class="muted">Os PNGs e o <code>equip.txt</code> sao carregados automaticamente a partir da pasta do projeto.</p>
        <div class="muted" style="margin-top:8px">
          PNGs carregados: <b id="countFiles">0</b>
        </div>
        <div class="muted" style="margin-top:4px">
          equip.txt: <b id="equipCount">(carregando)</b>
        </div>
        <div class="colsCtrl" title="Número de colunas visíveis" style="margin-top:12px">
          <span class="muted">Colunas:</span>
          <input id="colSliderConfig" class="colSlider" data-label="colLabelConfig" data-marks="colMarksConfig" type="range" min="1" max="10" step="1" value="5" list="colMarksConfig" />
          <datalist id="colMarksConfig"></datalist>
          <span id="colLabelConfig" class="muted caps">5</span>
        </div>
      </section>

      <section class="grid grid-4 stats">
        <div class="stat"><div class="l">Total de Itens</div><div id="stTotal" class="v">0</div></div>
        <div class="stat"><div class="l">Casaram por Object type</div><div id="stMatched" class="v">0</div></div>
        <div class="stat"><div class="l">Coletados</div><div id="stCollected" class="v">0</div></div>
        <div class="stat"><div class="l">Shiny</div><div id="stShiny" class="v">0</div></div>
        <div class="stat"><div class="l">White Bag</div><div id="stWhite" class="v">0</div></div>
      </section>

      <section class="card">
        <h3 style="margin:0 0 8px">Progresso (checklist)</h3>
        <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap">
          <button id="btnExport" class="btn">Exportar progresso (.json)</button>
          <label class="btn">Importar progresso (.json)
            <input id="inputProgress" class="hidden" type="file" accept=".json,application/json" />
          </label>
          <button id="btnClearProgress" class="btn" title="Limpar progresso salvo">Limpar progresso</button>
          <button id="btnConfigProgress" class="btn" title="Configurar arquivo local para auto-salvar">Configurar auto-salvar</button>
        </div>
        <div class="muted" style="margin-top:8px">
          Arquivo auto-salvar: <b id="progressFileLabel">Nao configurado</b><span id="progressFileStatus"> (navegador)</span>
        </div>
        <div class="muted" style="margin-top:8px">O progresso e salvo automaticamente no arquivo configurado (ou no navegador).</div>
      </section>

      <section class="card" style="grid-column:1/-1">
        <div style="display:flex;align-items:center;gap:10px;justify-content:space-between;flex-wrap:wrap">
          <h3 style="margin:0">Biblioteca de itens removidos</h3>
          <div id="removedInfo" class="muted"></div>
        </div>
        <div class="gallery" id="removedGallery" style="margin-top:10px"></div>
        <div id="removedEmpty" class="muted" style="display:none;margin-top:8px">Nenhum item removido.</div>
      </section>

      <section class="card" style="grid-column:1/-1">
        <div style="display:flex;align-items:center;gap:10px;justify-content:space-between;flex-wrap:wrap">
          <h3 style="margin:0">Itens não casados (por Object type)</h3>
          <div id="unmatchedInfo" class="muted"></div>
        </div>
        <div id="unmatchedGallery" class="gallery" style="margin-top:10px"></div>
        <div id="unmatchedEmpty" class="muted" style="display:none;margin-top:8px">Tudo certo: nenhum item pendente.</div>
      </section>
    </section>
  </main>

  <script>
    const $ = (sel) => document.querySelector(sel);
    const normHex = (s) => { if (!s) return ""; let x = s.trim().toLowerCase(); x = x.replace(/\s*\(\d+\)\s*$/, ""); if (!x.startsWith("0x")) x = "0x" + x.replace(/^0x/i,""); return x; };
    const hexToInt = (hx) => { const m = /^0x([0-9a-f]+)$/.exec((hx||"").toLowerCase()); return m ? parseInt(m[1], 16) : Number.POSITIVE_INFINITY; };
    const getCategoryFromPath = (relPath) => { const parts = (relPath || "").split("/").filter(Boolean); return parts.length > 1 ? parts[0] : ""; };
    const normStr = (s) => (s||"").toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g,"");
    function computeDefaultProgressInfo(){
      try{
        if(typeof window==="undefined") return null;
        if(window.location.protocol!=="file:") return null;
        let pathname=window.location.pathname||"";
        try{ pathname=decodeURIComponent(pathname); }catch(_){}
        if(!pathname) return null;
        // remove leading slash for Windows paths like /C:/...
        if(pathname.startsWith("/") && /^[A-Za-z]:/.test(pathname.slice(1))){
          pathname=pathname.slice(1);
        }
        pathname=pathname.replace(/\\/g,"/");
        const idx=pathname.lastIndexOf("/");
        if(idx<0) return null;
        const dirUnix=pathname.slice(0, idx);
        const fileUnix=dirUnix ? `${dirUnix}/${PROGRESS_FILE_NAME}` : PROGRESS_FILE_NAME;
        const isWindows=/^[A-Za-z]:/.test(dirUnix);
        const dirNative=isWindows?dirUnix.replace(/\//g,"\\"):dirUnix;
        const fileNative=isWindows?fileUnix.replace(/\//g,"\\"):fileUnix;
        return {
          isWindows,
          dirUnix,
          dirNative,
          fileUnix,
          fileNative,
          displayName:isWindows?fileNative:fileUnix,
          startInCandidate:isWindows?dirNative:(dirUnix||undefined)
        };
      }catch(err){
        console.warn("computeDefaultProgressInfo falhou:", err);
        return null;
      }
    }
    function getSuggestedSaveName(){
      if(DEFAULT_PROGRESS_INFO?.fileNative){
        return DEFAULT_PROGRESS_INFO.fileNative;
      }
      if(DEFAULT_PROGRESS_INFO?.fileUnix){
        return DEFAULT_PROGRESS_INFO.fileUnix;
      }
      return PROGRESS_FILE_NAME;
    }

    const LS_KEY="rotmg_progress_v1", COLS_KEY="rotmg_cols_v1";
    const PROGRESS_HANDLE_KEY="rotmg_progress_handle_v1";
    const PROGRESS_FILE_NAME="rotmg_progress.json";
    const OWNED_KEY_LEGACY="rotmg_only_owned_v1";
    const OWNED_MODE_KEY="rotmg_owned_mode_v1";
    const DB_NAME="rotmg_handles_db", DB_STORE="kv";
    let currentTab = "items";
    let progressWriteQueue=Promise.resolve();
    const DEFAULT_PROGRESS_INFO = computeDefaultProgressInfo();
    let nodeFsAdapter=initNodeFsAdapter();

    const DEFAULT_REMOVED = [
      "0xc184","0x913","0x1a2f","0x47a9","0x4b79","0x262","0x264","0x4b7a","0x47b6","0x47b3",
      "0x47b8","0xf4d","0x1424","0x1425","0x1426","0x142b","0x1427","0x1428","0x1429","0x142a",
      "0x149f","0x14a0","0x14a1","0x14a2","0x14a3","0x14a4","0x14a5","0x14a6","0x967c","0xf93",
      "0xf92","0x7fa","0x9d2","0x1e4e","0x7555","0x7556","0x7557","0x7559","0x755a","0xca22",
      "0x6587","0xc2d","0x5c4f","0xc40","0xc3e","0xc3f"
    ];

    const SPRITES_MANIFEST_URL = "./sprites_manifest.json";
    const SPRITES_BASE_URL = "../Sprites";
    const EQUIP_DEFAULT_URL = "../equip.txt";

    const state = {
      files: [],
      equipByType: null,
      sortMode: "objectid",
      sortDir: "asc",
      filter: "all",
      ownedMode: "any",     // "any" | "yes" | "no"
      collected: new Set(),
      searchQuery: "",
      deleteMode: false,
      removed: new Set(),
      pendingRemovals: 0,
      progressHandle: null
    };

    const WHITE_BAG_REGEX = /white\s*bag/i;
    // Mantém a lógica de categorização centralizada
    const isWhiteRow = (row) => {
      const category = row?.category || "";
      const bagtype = row?.bagtype || "";
      return category === "White Bag" || WHITE_BAG_REGEX.test(bagtype);
    };
    const isShinyRow = (row) => !!row?.isShiny;

    /* ===== IndexedDB: salvar/ler FileSystemHandles ===== */
    function idbOpen(){
      return new Promise((resolve,reject)=>{
        const req = indexedDB.open(DB_NAME, 1);
        req.onupgradeneeded = (ev)=>{
          const db = ev.target.result;
          if(!db.objectStoreNames.contains(DB_STORE)){
            db.createObjectStore(DB_STORE);
          }
        };
        req.onsuccess = ()=> resolve(req.result);
        req.onerror = ()=> reject(req.error);
      });
    }
    async function idbGet(key){
      try{
        const db = await idbOpen();
        return await new Promise((resolve,reject)=>{
          const tx=db.transaction(DB_STORE,"readonly");
          const st=tx.objectStore(DB_STORE);
          const g=st.get(key);
          g.onsuccess=()=>resolve(g.result||null);
          g.onerror =()=>reject(g.error);
        });
      }catch(e){ return null; }
    }
    async function idbSet(key, value){
      try{
        const db = await idbOpen();
        return await new Promise((resolve,reject)=>{
          const tx=db.transaction(DB_STORE,"readwrite");
          const st=tx.objectStore(DB_STORE);
          const p=st.put(value, key);
          p.onsuccess=()=>resolve(true);
          p.onerror =()=>reject(p.error);
        });
      }catch(e){ console.warn("idbSet falhou:", e); }
    }
    async function idbDel(key){
      try{
        const db = await idbOpen();
        return await new Promise((resolve,reject)=>{
          const tx=db.transaction(DB_STORE,"readwrite");
          const st=tx.objectStore(DB_STORE);
          const d=st.delete(key);
          d.onsuccess=()=>resolve(true);
          d.onerror =()=>reject(d.error);
        });
      }catch(e){}
    }

    async function ensurePersistentStorage(){
      try{
        if(navigator.storage && navigator.storage.persist){
          await navigator.storage.persist();
        }
      }catch(e){}
    }
    async function ensurePerm(handle, mode="read"){
      try{
        if(!handle || !handle.queryPermission) return true;
        const q = await handle.queryPermission({mode});
        if(q === "granted") return true;
        if(q === "prompt"){
          const r = await handle.requestPermission({mode});
          return r === "granted";
        }
        return false;
      }catch(e){
        return false;
      }
    }

    function buildSpriteUrl(relPath){
      const base = SPRITES_BASE_URL.replace(/\/+$/,"");
      return encodeURI(`${base}/${relPath}`);
    }

    async function loadSpritesFromManifest(){
      try{
        const resp = await fetch(SPRITES_MANIFEST_URL, {cache:"no-cache"});
        if(!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const manifest = await resp.json();
        if(!Array.isArray(manifest)) throw new Error("Manifesto invalido");
        state.files.forEach((f)=>{
          if(f?.url && typeof f.url==="string" && f.url.startsWith("blob:")){
            try{ URL.revokeObjectURL(f.url); }catch(_){}
          }
        });
        const arr = manifest.filter((rel)=>typeof rel==="string" && rel.toLowerCase().endsWith(".png")).map((rel)=>{
          const base=(rel.split("/").pop()||"").replace(/\.png$/i,"");
          return {
            file:null,
            url:buildSpriteUrl(rel),
            path:rel,
            category:getCategoryFromPath(rel),
            objType:normHex(base)
          };
        });
        const newObjTypes=new Set(arr.map((f)=>f.objType));
        state.files=arr;
        state.removed=new Set(Array.from(state.removed).filter((objType)=>newObjTypes.has(objType)));
        saveProgress({skipFile:true});
        const countEl=$("#countFiles");
        if(countEl) countEl.textContent=String(arr.length);
        return true;
      }catch(err){
        console.error("Falha ao carregar sprites padrao:", err);
        const countEl=$("#countFiles");
        if(countEl) countEl.textContent="erro";
        state.files=[];
        return false;
      }
    }

    async function loadEquipFromDefault(){
      try{
        const resp = await fetch(EQUIP_DEFAULT_URL, {cache:"no-cache"});
        if(!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const text = await resp.text();
        state.equipByType = parseEquipTxt(text);
        const equipEl=$("#equipCount");
        if(equipEl) equipEl.textContent = state.equipByType ? `${state.equipByType.size} objetos` : "(nao carregado)";
        return true;
      }catch(err){
        console.error("Falha ao carregar equip.txt padrao:", err);
        state.equipByType=null;
        const equipEl=$("#equipCount");
        if(equipEl) equipEl.textContent="erro";
        return false;
      }
    }

    function getProgressData(){
      return {
        version:1,
        collected:Array.from(state.collected),
        removed:Array.from(state.removed)
      };
    }
    function updateProgressFileInfo({name,status}={}){
      const label=document.getElementById("progressFileLabel");
      const statusEl=document.getElementById("progressFileStatus");
      let finalName=name;
      let finalStatus=status;
      if(finalName===undefined && nodeFsAdapter){
        finalName=nodeFsAdapter.displayName || nodeFsAdapter.fileName || PROGRESS_FILE_NAME;
        if(finalStatus===undefined) finalStatus="auto";
      }else if(finalName===undefined && DEFAULT_PROGRESS_INFO?.displayName){
        finalName=DEFAULT_PROGRESS_INFO.displayName;
        if(finalStatus===undefined) finalStatus="sugestao";
      }else if(finalStatus===undefined && finalName===undefined){
        finalStatus="navegador";
      }
      if(label && finalName!==undefined){
        label.textContent = finalName || "Nao configurado";
      }
      if(statusEl && finalStatus!==undefined){
        statusEl.textContent = finalStatus ? ` (${finalStatus})` : "";
      }
    }
    async function clearProgressHandle({status}={}){
      state.progressHandle=null;
      try{ await idbDel(PROGRESS_HANDLE_KEY); }catch(_){}
      if(nodeFsAdapter){
        updateProgressFileInfo({name:nodeFsAdapter.displayName, status: status ?? "auto"});
      }else{
        updateProgressFileInfo({status: status ?? "navegador"});
      }
    }
    function scheduleProgressWrite(data){
      if(nodeFsAdapter){
        progressWriteQueue = progressWriteQueue.then(()=>writeProgressNode(data)).catch((err)=>{
          console.warn("Falha ao salvar progresso no caminho padrao:", err);
        });
        return;
      }
      if(!state.progressHandle) return;
      progressWriteQueue = progressWriteQueue.then(()=>writeProgressFile(state.progressHandle,data)).catch((err)=>{
        console.warn("Falha ao salvar progresso no arquivo:", err);
      });
    }
    function initNodeFsAdapter(){
      try{
        if(typeof window==="undefined") return null;
        if(window.location.protocol!=="file:") return null;
        if(!DEFAULT_PROGRESS_INFO?.dirUnix) return null;
        let req=null;
        if(typeof window.require==="function") req=window.require;
        else if(typeof window.nodeRequire==="function") req=window.nodeRequire;
        else if(typeof globalThis!=="undefined" && typeof globalThis.require==="function") req=globalThis.require;
        else if(typeof require==="function") req=require;
        if(!req) return null;
        let fs=null;
        let pathMod=null;
        try{
          fs=req("fs");
          pathMod=req("path");
        }catch(_){
          return null;
        }
        if(!fs || !pathMod) return null;
        const dirPath = pathMod.resolve(DEFAULT_PROGRESS_INFO.dirNative || DEFAULT_PROGRESS_INFO.dirUnix || ".");
        const filePath = pathMod.resolve(dirPath, PROGRESS_FILE_NAME);
        const fsPromises=fs.promises;
        const write=async(content)=>{
          if(fsPromises?.writeFile){
            await fsPromises.writeFile(filePath, content, "utf8");
          }else{
            await new Promise((resolve,reject)=>fs.writeFile(filePath, content, "utf8",(err)=>err?reject(err):resolve()));
          }
        };
        const read=async()=>{
          try{
            if(fsPromises?.readFile){
              return await fsPromises.readFile(filePath,"utf8");
            }
            return await new Promise((resolve,reject)=>fs.readFile(filePath,"utf8",(err,data)=>err?reject(err):resolve(data)));
          }catch(err){
            if(err && (err.code==="ENOENT"||err.code==="NotFoundError")) return null;
            throw err;
          }
        };
        return {
          type:"node",
          write,
          read,
          filePath,
          fileName:PROGRESS_FILE_NAME,
          displayName:filePath
        };
      }catch(err){
        console.warn("initNodeFsAdapter falhou:", err);
        return null;
      }
    }
    async function writeProgressNode(data){
      if(!nodeFsAdapter) return;
      try{
        await nodeFsAdapter.write(JSON.stringify(data,null,2));
        updateProgressFileInfo({name:nodeFsAdapter.displayName, status:"auto"});
      }catch(err){
        console.warn("Erro ao escrever arquivo de progresso padrao:", err);
        updateProgressFileInfo({name:nodeFsAdapter.displayName, status:"erro"});
        throw err;
      }
    }
    async function loadProgressFromNodeFile(){
      if(!nodeFsAdapter) return "skip";
      try{
        const text=await nodeFsAdapter.read();
        if(text && text.trim()){
          const json=JSON.parse(text);
          const collected=Array.isArray(json?.collected)?json.collected:[];
          const removedArr=Array.isArray(json?.removed)?json.removed:DEFAULT_REMOVED;
          state.collected=new Set(collected.map(normHex));
          state.removed=new Set(removedArr.map(normHex));
          updateProgressFileInfo({name:nodeFsAdapter.displayName, status:"auto"});
          return "loaded";
        }
        updateProgressFileInfo({name:nodeFsAdapter.displayName, status:"auto"});
        return text===null?"missing":"empty";
      }catch(err){
        console.warn("Falha ao ler arquivo de progresso padrao:", err);
        updateProgressFileInfo({name:nodeFsAdapter.displayName, status:"erro"});
        return "error";
      }
    }
    async function writeProgressFile(handle,data){
      if(!handle?.createWritable) return;
      try{
        const canWrite = await ensurePerm(handle,"readwrite");
        if(!canWrite){
          updateProgressFileInfo({status:"precisa permissao"});
          return;
        }
        const writable=await handle.createWritable();
        await writable.write(JSON.stringify(data,null,2));
        await writable.close();
        updateProgressFileInfo({name:handle.name||PROGRESS_FILE_NAME, status:"auto"});
      }catch(err){
        console.warn("Erro ao escrever arquivo de progresso:", err);
        if(err?.name==="NotAllowedError"||err?.name==="NotFoundError"){
          await clearProgressHandle({status:"precisa configurar"});
        }else{
          updateProgressFileInfo({status:"erro"});
        }
      }
    }
    async function loadProgressFromHandle(handle,{silent=false}={}){
      if(!handle?.getFile) return "error";
      try{
        const file=await handle.getFile();
        const text=await file.text();
        if(!text.trim()) return "empty";
        const json=JSON.parse(text);
        const collected=Array.isArray(json?.collected)?json.collected:[];
        const removedArr=Array.isArray(json?.removed)?json.removed:DEFAULT_REMOVED;
        state.collected=new Set(collected.map(normHex));
        state.removed=new Set(removedArr.map(normHex));
        return "loaded";
      }catch(err){
        if(!silent) console.warn("Falha ao ler arquivo de progresso lembrado:", err);
        return "error";
      }
    }
    function getPickerStartIn(){
      return DEFAULT_PROGRESS_INFO?.startInCandidate;
    }
    async function configureProgressFile(){
      if(nodeFsAdapter){
        alert(`O progresso ja esta configurado para salvar automaticamente em:\n${nodeFsAdapter.displayName}`);
        updateProgressFileInfo({name:nodeFsAdapter.displayName, status:"auto"});
        return;
      }
      if(!window.showSaveFilePicker && !window.showOpenFilePicker){
        alert("Navegador sem suporte para auto-salvar arquivo. Continue usando a exportacao manual.");
        return;
      }
      const pickerTypes=[{description:"Progresso ROTMG", accept:{"application/json":[".json"]}}];
      try{
        let handle=null;
        if(window.showSaveFilePicker){
          const baseOpts={
            suggestedName:getSuggestedSaveName(),
            types:pickerTypes,
            excludeAcceptAllOption:false,
            id:"rotmg-autosave"
          };
          const startIn=getPickerStartIn();
          let opts=startIn?{...baseOpts,startIn}:{...baseOpts};
          let attemptedFallback=false;
          try{
            handle=await window.showSaveFilePicker(opts);
          }catch(err){
            if(err?.name==="TypeError" && !attemptedFallback){
              attemptedFallback=true;
              const fallbackOpts={suggestedName:getSuggestedSaveName(), types:pickerTypes, excludeAcceptAllOption:false};
              handle=await window.showSaveFilePicker(fallbackOpts);
            }else{
              throw err;
            }
          }
        }else{
          const baseOpts={
            multiple:false,
            types:pickerTypes,
            excludeAcceptAllOption:false,
            id:"rotmg-autosave"
          };
          const startIn=getPickerStartIn();
          let opts=startIn?{...baseOpts,startIn}:{...baseOpts};
          let picked;
          let attemptedFallback=false;
          try{
            picked=await window.showOpenFilePicker(opts);
          }catch(err){
            if(err?.name==="TypeError" && !attemptedFallback){
              attemptedFallback=true;
              const fallbackOpts={multiple:false, types:pickerTypes, excludeAcceptAllOption:false};
              picked=await window.showOpenFilePicker(fallbackOpts);
            }else{
              throw err;
            }
          }
          handle=picked?.[0]||null;
        }
        if(!handle) return;
        updateProgressFileInfo({name:handle.name||PROGRESS_FILE_NAME, status:"aguardando"});
        const allowed=await ensurePerm(handle,"readwrite");
        if(!allowed){
          alert("Permissao negada para escrever no arquivo escolhido.");
          updateProgressFileInfo({name:handle.name||PROGRESS_FILE_NAME, status:"precisa permissao"});
          return;
        }
        state.progressHandle=handle;
        try{ await idbSet(PROGRESS_HANDLE_KEY, handle); }catch(_){}
        const result=await loadProgressFromHandle(handle);
        if(result==="loaded"){
          saveProgress({skipFile:true});
          renderAll();
        }else{
          if(result==="error"){
            alert("Conteudo do arquivo selecionado e invalido. O estado atual sera escrito nele.");
          }
          await writeProgressFile(handle, getProgressData());
        }
        updateProgressFileInfo({name:handle.name||PROGRESS_FILE_NAME, status:"auto"});
      }catch(err){
        if(err?.name==="AbortError") return;
        console.error(err);
        alert("Nao foi possivel configurar o auto-salvar. Veja o console para detalhes.");
      }
    }

    /* ===== Progresso (coletados) ===== */
    function loadProgress(){
      let loaded=false;
      try{
        const raw=localStorage.getItem(LS_KEY);
        if(raw){
          const parsed=JSON.parse(raw);
          const arr=Array.isArray(parsed?.collected)?parsed.collected:[];
          state.collected=new Set(arr.map(normHex));
          const removedArr=Array.isArray(parsed?.removed)?parsed.removed:DEFAULT_REMOVED;
          state.removed=new Set(removedArr.map(normHex));
          loaded=true;
        }
      }catch(e){}
      if(!loaded){
        state.collected.clear();
        state.removed=new Set(DEFAULT_REMOVED.map(normHex));
      }
    }
    function saveProgress({skipFile=false}={}){
      const data=getProgressData();
      try{
        localStorage.setItem(LS_KEY, JSON.stringify(data));
      }catch(e){}
      if(!skipFile) scheduleProgressWrite(data);
    }
    function exportProgress(){
      const data=getProgressData();
      const blob=new Blob([JSON.stringify(data,null,2)],{type:"application/json"});
      const url=URL.createObjectURL(blob);
      const a=document.createElement("a"); a.href=url; a.download=PROGRESS_FILE_NAME;
      document.body.appendChild(a); a.click(); URL.revokeObjectURL(url); a.remove();
    }
    async function importProgress(file){
      const text=await file.text(); const json=JSON.parse(text);
      const arr=Array.isArray(json?.collected)?json.collected:[];
      state.collected=new Set(arr.map(normHex));
      const removedArr=Array.isArray(json?.removed)?json.removed:DEFAULT_REMOVED;
      state.removed=new Set(removedArr.map(normHex));
      saveProgress(); renderAll();
    }
    function clearProgress(){
      state.collected.clear();
      state.removed.clear();
      state.deleteMode=false;
      saveProgress();
      renderAll();
    }

    /* ===== equip.txt parser (DisplayId + id) ===== */
    function parseEquipTxt(text){
      const xml=new DOMParser().parseFromString(text,"text/xml");
      const hasErr=xml.getElementsByTagName("parsererror").length>0;
      const byType=new Map();

      const firstText = (nodeList) => {
        for (const n of nodeList||[]) {
          const t = (n.textContent||"").trim();
          if (t) return t;
        }
        return "";
      };

      const collectObjNode=(obj)=>{
        const typeAttr=(obj.getAttribute?.("type")||"").trim().toLowerCase(); if(!typeAttr) return;
        const key=normHex(typeAttr);
        const idAttr=(obj.getAttribute?.("id")||"").trim();

        const displayNode = obj.getElementsByTagName?.("DisplayId") || [];
        const displayNodeLower = obj.getElementsByTagName?.("displayId") || [];
        const displayIdStrict = firstText(displayNode.length?displayNode:displayNodeLower);

        // labels
        let labels=[];
        const labelsNode=obj.querySelector?.("Labels");
        if(labelsNode && labelsNode.textContent.trim()){
          labels=labelsNode.textContent.split(/[,;\s]+/).map(s=>s.trim()).filter(Boolean);
        }
        const labelNodes=Array.from(obj.getElementsByTagName?.("Label")||[]);
        if(labelNodes.length) labels.push(...labelNodes.map(n=>(n.textContent||"").trim()).filter(Boolean));
        labels=Array.from(new Set(labels));

        const tier=obj.querySelector?.("Tier")?.textContent?.trim()||"";
        const slot=obj.querySelector?.("SlotType")?.textContent?.trim()||"";
        const bagtype=obj.querySelector?.("BagType")?.textContent?.trim()||"";

        byType.set(key,{objType:key,displayIdStrict,idAttr,labels,tier,slot,bagtype});
      };

      if(!hasErr){
        const objs=Array.from(xml.getElementsByTagName("Object"));
        for(const obj of objs) collectObjNode(obj);
        if(byType.size>0) return byType;
      }

      // Fallback texto
      const objRe=/<Object\b([^>]*)>([\s\S]*?)<\/Object\s*>/gi;
      const getAttr=(attrs,name)=>{ const m=new RegExp(`(?:^|\\s)${name}\\s*=\\s*["']([^"']+)["']`,"i").exec(attrs||""); return m?m[1].trim():""; };
      const getTag=(block,tag)=>{ const m=new RegExp(`<${tag}\\b[^>]*>([\\s\\S]*?)<\\/${tag}>`,"i").exec(block||""); return m?m[1].trim():""; };
      const getManyTags=(block,tag)=>{ const re=new RegExp(`<${tag}\\b[^>]*>([\\s\\S]*?)<\\/${tag}>`,"gi"); const out=[]; let mm; while((mm=re.exec(block||""))) out.push((mm[1]||"").trim()); return out; };

      let m; while((m=objRe.exec(text))){
        const attrs=m[1]||"", block=m[2]||"";
        const typeAttrRaw=getAttr(attrs,"type"); if(!typeAttrRaw) continue;
        const key=normHex(typeAttrRaw.toLowerCase());
        const idAttr=getAttr(attrs,"id");
        const displayIdStrict=getTag(block,"DisplayId")||"";

        let labels=[]; const labelsText=getTag(block,"Labels"); if(labelsText) labels=labelsText.split(/[,;\s]+/).map(s=>s.trim()).filter(Boolean);
        const labelList=getManyTags(block,"Label"); if(labelList.length) labels.push(...labelList.filter(Boolean));
        labels=Array.from(new Set(labels));

        const tier=getTag(block,"Tier"); const slot=getTag(block,"SlotType"); const bagtype=getTag(block,"BagType");
        byType.set(key,{objType:key,displayIdStrict,idAttr,labels,tier,slot,bagtype});
      }
      return byType;
    }

    async function restoreRemembered(){

      await ensurePersistentStorage();



      await loadSpritesFromManifest();

      await loadEquipFromDefault();



      if(nodeFsAdapter){

        const result=await loadProgressFromNodeFile();

        if(result==="loaded"){

          saveProgress({skipFile:true});

        }else if(result==="missing"){

          try{ await writeProgressNode(getProgressData()); }catch(_){ }

        }

        return;

      }



      if(!window.showOpenFilePicker && !window.showSaveFilePicker) return;



      const progressHandle = await idbGet(PROGRESS_HANDLE_KEY);

      if(progressHandle){

        state.progressHandle=progressHandle;

        const handleName=progressHandle.name||PROGRESS_FILE_NAME;

        updateProgressFileInfo({name:handleName, status:"aguardando"});

        if(await ensurePerm(progressHandle,"read")){

          const loadResult=await loadProgressFromHandle(progressHandle,{silent:true});

          if(loadResult==="loaded"){

            saveProgress({skipFile:true});

          }else if(loadResult==="error"){

            updateProgressFileInfo({name:handleName, status:"erro"});

          }else if(loadResult==="empty"){

            updateProgressFileInfo({name:handleName, status:"arquivo vazio"});

          }

          const canWrite=await ensurePerm(progressHandle,"readwrite");

          if(canWrite){

            if(loadResult==="empty"){

              scheduleProgressWrite(getProgressData());

            }

            updateProgressFileInfo({name:handleName, status:"auto"});

          }else{

            updateProgressFileInfo({name:handleName, status:"somente leitura"});

          }

        }else{

          updateProgressFileInfo({name:handleName, status:"precisa permissao"});

        }

      }

    }



    /* ===== Derivação ===== */
    function deriveRows(){
      return state.files.map((f)=>{
        const rec=state.equipByType?.get(f.objType)||null;
        const labels=rec?.labels||[]; const bagtype=rec?.bagtype||"";
        const isShinyByEquip=labels.some(lb=>(lb||"").toUpperCase()==="SHINY");
        const isShinyByFolder=(f.category||"")==="Shiny";
        const isShiny=isShinyByEquip||isShinyByFolder;

        const displayIdStrict = rec?.displayIdStrict || "";
        const idAttr = rec?.idAttr || "";
        const displayName = displayIdStrict || idAttr || "";  // Nome exibido e usado no link

        const objectId=idAttr||"";

        return {
          key:f.path,
          imgUrl:f.url,
          displayName,
          objectId,
          objType:f.objType,
          isShiny,
          category:f.category||"",
          bagtype,
          labels,
          matched:!!rec,
          path:f.path,
          collected: state.collected.has(f.objType),
          searchKey: normStr(displayName)
        };
      });
    }

    /* ===== Render ITENS ===== */
    function renderItemsGallery(rows, matchedRows){
      const g=$("#gallery"), info=$("#itemsInfo"), empty=$("#galleryEmpty");
      if(!g) return;
      g.replaceChildren(); empty.style.display="none";
      const allRows = rows || deriveRows();

      // Filtro de categoria
      let matched=(matchedRows || allRows.filter(r=>r.matched)).filter(r=>{
        if(state.filter==="white") return isWhiteRow(r);
        if(state.filter==="shiny") return isShinyRow(r);
        return true;
      });
      // Filtro por coleta (tri-state)
      if(state.ownedMode==="yes") matched = matched.filter(r=> r.collected);
      else if(state.ownedMode==="no") matched = matched.filter(r=> !r.collected);

      // Filtro de busca (por nome)
      const q = normStr(state.searchQuery || "");
      if(q){
        matched = matched.filter(r => (r.searchKey || "").includes(q));
      }

      if(!state.equipByType){
        info.textContent="equip.txt padrao ainda nao carregado. Verifique se o arquivo esta acessivel.";
        empty.textContent=""; empty.style.display="block"; return;
      }

      // Ordenação
      if(state.sortMode==="objectid"){
        const collator=new Intl.Collator("pt-BR",{sensitivity:"base"});
        const getSortKey=(row)=>{
          const id=row.objectId||"";
          if(/^\d/.test(id)){
            const name=row.displayName||"";
            return name || id;
          }
          return id;
        };
        matched.sort((a,b)=>collator.compare(getSortKey(a), getSortKey(b)));
      } else {
        matched.sort((a,b)=>hexToInt(a.objType)-hexToInt(b.objType));
      }
      if(state.sortDir==="desc") matched.reverse();

      matched = matched.filter(r=> !state.removed.has(r.objType));

      const fltLabel = state.filter==="white" ? "White Bag" : state.filter==="shiny" ? "Shiny" : "Todos";
      const ownLabel = state.ownedMode==="yes" ? " | Somente coletados" : state.ownedMode==="no" ? " | Somente não coletados" : "";
      const searchLabel = q ? ` | Pesquisa: "${state.searchQuery}"` : "";
      info.textContent = `Exibindo ${matched.length} item(ns) — Filtro: ${fltLabel}${ownLabel}${searchLabel} | ${state.sortMode==="objectid"?"A→Z (ObjectId)":"Hex (Object type)"} / ${state.sortDir.toUpperCase()}. Clique para marcar coletado.`;

      if(matched.length===0){ empty.textContent="Nenhum item encontrado para o filtro atual."; empty.style.display="block"; return; }

      const frag=document.createDocumentFragment();
      for(const r of matched){
        const wrap=document.createElement("div");
        wrap.className="tile"+(r.collected?" checked":"");
        if(r.isShiny) wrap.classList.add("shiny");
        if(isWhiteRow(r)) wrap.classList.add("white");
        wrap.dataset.objtype=r.objType;

        const div=document.createElement("div"); div.className="thumb";

        // Ícone (i) — só se tiver um displayName
        if (r.displayName) {
          const q2 = encodeURIComponent('"' + r.displayName + '"');
          const realmUrl = "https://www.realmeye.com/wiki-search?q=" + q2;

          const infoLink=document.createElement("a");
          infoLink.href = realmUrl;
          infoLink.target="_blank"; infoLink.rel="noopener";
          infoLink.className="info-btn"; infoLink.title="Abrir no RealmEye";
          infoLink.textContent="i";
          infoLink.addEventListener("click",(e)=>{ e.stopPropagation(); });
          div.appendChild(infoLink);

          const closeBtn=document.createElement("button");
          closeBtn.type="button";
          closeBtn.className="close-btn";
          closeBtn.title="Enviar item para a biblioteca";
          closeBtn.textContent="X";
          closeBtn.addEventListener("click",(e)=>{
            e.stopPropagation();
            if(!state.deleteMode) return;
            handleRemove(wrap);
          });
          div.appendChild(closeBtn);
        }

        const img=document.createElement("img");
        img.src=r.imgUrl; img.loading="lazy";
        img.alt = r.displayName;
        img.title = r.displayName;
        div.appendChild(img);

        const cap=document.createElement("div"); cap.className="cap";
        cap.textContent = r.displayName;
        wrap.appendChild(div); wrap.appendChild(cap); frag.appendChild(wrap);
      }
      g.replaceChildren(frag);

      const handleRemove=(tile)=>{
        if(!tile || tile.classList.contains("is-removing")) return;
        const objType=tile.dataset?.objtype;
        if(!objType) return;
        tile.classList.add("is-removing");
        state.pendingRemovals=(state.pendingRemovals||0)+1;
        state.removed.add(objType);
        state.collected.delete(objType);
        const rect=tile.getBoundingClientRect();
        const clone=tile.cloneNode(true);
        clone.classList.add("tile-clone");
        clone.classList.remove("is-removing");
        clone.style.position="fixed";
        clone.style.width=`${rect.width}px`;
        clone.style.height=`${rect.height}px`;
        clone.style.top=`${rect.top}px`;
        clone.style.left=`${rect.left}px`;
        clone.style.setProperty('--fly-x','0px');
        clone.style.setProperty('--fly-y','0px');
        clone.style.transform='translate3d(0,0,0)';
        document.body.appendChild(clone);

        let deltaX=180, deltaY=-120;
        const target=document.getElementById("tabConfigBtn");
        if(target){
          const tileRect=rect;
          const targetRect=target.getBoundingClientRect();
          deltaX=(targetRect.left + targetRect.width/2) - (tileRect.left + tileRect.width/2);
          deltaY=(targetRect.top + targetRect.height/2) - (tileRect.top + tileRect.height/2);
        }
        clone.style.setProperty('--fly-x', `${deltaX}px`);
        clone.style.setProperty('--fly-y', `${deltaY}px`);
        clone.classList.add("removing");
        let finished=false;
        let fallbackId=null;
        const finish=()=>{
          if(finished) return;
          finished=true;
          clone.removeEventListener("animationend", finish);
          if(fallbackId!==null) clearTimeout(fallbackId);
          clone.remove();
          const preserveScroll = window.scrollY;
          saveProgress();
          state.pendingRemovals=Math.max(0,(state.pendingRemovals||1)-1);
          const finalizeRender = ()=>{
            if(handleRemove._renderTimer){
              clearTimeout(handleRemove._renderTimer);
              handleRemove._renderTimer=null;
            }
            renderAll();
            requestAnimationFrame(()=>{ window.scrollTo({top:preserveScroll,left:window.scrollX,behavior:"auto"}); });
          };
          if(state.pendingRemovals===0){
            finalizeRender();
          } else {
            clearTimeout(handleRemove._renderTimer);
            handleRemove._renderTimer=setTimeout(finalizeRender, 300);
          }
        };
        clone.addEventListener("animationend", finish);
        fallbackId=setTimeout(finish, 1400);
      };

      // Toggle coletado ou exclusão (dependendo do modo)
      g.onclick=(ev)=>{
        const tile=ev.target.closest(".tile");
        if(!tile) return;
        if(state.deleteMode){
          handleRemove(tile);
          return;
        }
        const objType=tile.dataset.objtype; if(!objType) return;
        if(state.collected.has(objType)) state.collected.delete(objType); else state.collected.add(objType);
        saveProgress(); renderAll();
      };
    }

    /* ===== Render CONFIG ===== */
    function renderRemoved(rows){
      const cont=$("#removedGallery"), info=$("#removedInfo"), empty=$("#removedEmpty");
      if(!cont) return;
      cont.replaceChildren(); empty.style.display="none";
      const allRows = rows || deriveRows();
      const removedRows = allRows.filter(r=> state.removed.has(r.objType));

      if(removedRows.length){
        info.textContent = `${removedRows.length} item(ns) armazenado(s). Clique no item para devolver à galeria.`;
      } else {
        info.textContent = "";
      }

      if(removedRows.length===0){
        empty.style.display="block";
        return;
      }

      const frag=document.createDocumentFragment();
      for(const r of removedRows){
        const wrap=document.createElement("div"); wrap.className="tile"; wrap.dataset.objtype=r.objType;
        const box=document.createElement("div"); box.className="thumb";

        if(r.displayName){
          const q2 = encodeURIComponent('"' + r.displayName + '"');
          const realmUrl = "https://www.realmeye.com/wiki-search?q=" + q2;
          const infoLink=document.createElement("a");
          infoLink.href = realmUrl;
          infoLink.target="_blank"; infoLink.rel="noopener";
          infoLink.className="info-btn"; infoLink.title="Abrir no RealmEye";
          infoLink.textContent="i";
          infoLink.addEventListener("click",(e)=>{ e.stopPropagation(); });
          box.appendChild(infoLink);
        }

        const img=document.createElement("img");
        img.src=r.imgUrl; img.loading="lazy";
        img.alt = r.displayName;
        img.title = r.displayName;
        box.appendChild(img);

        const cap=document.createElement("div"); cap.className="cap";
        cap.textContent = r.displayName;

        const overlay=document.createElement("div");
        overlay.className="restore-overlay";
        overlay.innerHTML='<span class="restore-icon">↺</span>';
        box.appendChild(overlay);

        wrap.appendChild(box);
        wrap.appendChild(cap);
        wrap.addEventListener("click",()=>{
          state.removed.delete(r.objType);
          saveProgress();
          renderAll();
        });
        frag.appendChild(wrap);
      }

      cont.replaceChildren(frag);
    }

    function renderUnmatched(rows){
      const cont=$("#unmatchedGallery"), info=$("#unmatchedInfo"), empty=$("#unmatchedEmpty");
      if(!cont) return;
      cont.replaceChildren(); empty.style.display="none";
      const allRows = rows || deriveRows();
      const unmatched=allRows.filter(r=>!r.matched);

      if(!state.equipByType) info.textContent=`equip.txt padrao nao carregado - exibindo ${unmatched.length} arquivo(s) como pendentes.`;
      else info.textContent=`${unmatched.length} arquivo(s) sem correspondencia no equip.txt (por Object type).`;

      if(unmatched.length===0){ empty.style.display="block"; return; }

      const frag=document.createDocumentFragment();
      for(const r of unmatched){
        const wrap=document.createElement("div"); wrap.className="tile";
        const box=document.createElement("div"); box.className="thumb";
        const img=document.createElement("img");
        img.src=r.imgUrl; img.loading="lazy";
        img.alt=""; img.title="";
        box.appendChild(img);
        const cap=document.createElement("div"); cap.className="cap"; cap.textContent=r.objType||"(sem objType)";
        wrap.appendChild(box); wrap.appendChild(cap); frag.appendChild(wrap);
      }
      cont.replaceChildren(frag);
    }

    function renderProgressBars(matchedRows){
      const shinyFill=$("#progShinyFill"), shinyText=$("#progShinyText");
      const whiteFill=$("#progWhiteFill"), whiteText=$("#progWhiteText");
      if(!shinyFill||!whiteFill) return;

      const rowsMatched = (matchedRows || deriveRows().filter(r=>r.matched))
        .filter(r=> !state.removed.has(r.objType));
      const shinyTotal=rowsMatched.filter(isShinyRow).length;
      const shinyCollected=rowsMatched.filter(r=>isShinyRow(r) && state.collected.has(r.objType)).length;
      const whiteTotal=rowsMatched.filter(isWhiteRow).length;
      const whiteCollected=rowsMatched.filter(r=>isWhiteRow(r) && state.collected.has(r.objType)).length;
      const pct=(c,t)=> t? Math.max(0,Math.min(100,Math.round((c/t)*100))) : 0;

      shinyFill.style.width=pct(shinyCollected,shinyTotal)+"%";
      whiteFill.style.width=pct(whiteCollected,whiteTotal)+"%";
      shinyText.textContent=`${shinyCollected}/${shinyTotal} (${pct(shinyCollected,shinyTotal)}%)`;
      whiteText.textContent=`${whiteCollected}/${whiteTotal} (${pct(whiteCollected,whiteTotal)}%)`;
    }

    function renderStats(rows, matchedRows){
      const stTotal=$("#stTotal"); if(!stTotal) return;
      const allRows=rows || deriveRows();
      const rowsMatched=matchedRows || allRows.filter(r=>r.matched);
      const visibleMatched = rowsMatched.filter(r=> !state.removed.has(r.objType));
      const collectedCount=visibleMatched.filter(r=>state.collected.has(r.objType)).length;

      $("#stTotal").textContent   = allRows.length;
      $("#stMatched").textContent = visibleMatched.length;
      $("#stCollected").textContent = collectedCount;
      $("#stShiny").textContent   = visibleMatched.filter(isShinyRow).length;
      $("#stWhite").textContent   = visibleMatched.filter(isWhiteRow).length;
      const countEl=$("#countFiles");
      if(countEl) countEl.textContent = String(allRows.length);
      const equipEl=$("#equipCount");
      if(equipEl) equipEl.textContent = state.equipByType ? `${state.equipByType.size} objetos` : "(nao carregado)";
    }

    function renderAll(){
      document.body.classList.toggle("delete-mode", state.deleteMode);
      const deleteToggle=document.getElementById("deleteModeToggle");
      if(deleteToggle) deleteToggle.checked = state.deleteMode;
      const rows = deriveRows();
      const matchedRows = rows.filter(r=>r.matched);
      if(currentTab === "items"){
        renderItemsGallery(rows, matchedRows);
        renderProgressBars(matchedRows);
      } else {
        renderStats(rows, matchedRows);
        renderRemoved(rows);
        renderUnmatched(rows);
      }
    }

    /* ===== Colunas (slider) ===== */
    const MIN_IMAGE_PX=10, THUMB_PAD=2, THUMB_BORDER=1;
    function computeMaxCols(){
      const g=document.getElementById("gallery");
      const width=g?.clientWidth||document.body.clientWidth||1200;
      const gap=parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap'))||8;
      const minTilePx=MIN_IMAGE_PX+2*THUMB_PAD+2*THUMB_BORDER; // 16px mínimo
      return Math.max(1, Math.floor((width+gap)/(minTilePx+gap)));
    }
    function computeTileSize(n){
      const g=document.getElementById("gallery");
      const width=g?.clientWidth||document.body.clientWidth||1200;
      const gap=parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap'))||8;
      const tile = (width - (n-1)*gap)/n;
      return Math.max(16, tile); // nunca menor que 16px
    }
    function getColControls(){
      return Array.from(document.querySelectorAll(".colSlider")).map((slider)=>{
        const labelId = slider.getAttribute("data-label");
        const marksId = slider.getAttribute("data-marks");
        return {
          slider,
          label: labelId ? document.getElementById(labelId) : null,
          marks: marksId ? document.getElementById(marksId) : null
        };
      });
    }
    function applyCols(n){
      document.documentElement.style.setProperty('--cols', String(n));

      // tamanho do tile -> CSS
      const tilePx = computeTileSize(n);
      document.documentElement.style.setProperty('--tile', tilePx+'px');

      const controls=getColControls();
      for(const {slider,label} of controls){
        slider.value=String(n);
        slider.setAttribute("aria-valuenow", slider.value);
        if(label) label.textContent=String(n);
      }

      // Alterna classes no <body> e no #gallery (mais robusto)
      const gallery = document.getElementById("gallery");
      const hideCaps = n >= 18;
      const hideInfo = n >= 25;

      document.body.classList.toggle('hide-captions', hideCaps);
      document.body.classList.toggle('hide-info', hideInfo);
      if (gallery){
        gallery.classList.toggle('hide-captions', hideCaps);
        gallery.classList.toggle('hide-info', hideInfo);
      }
    }
    function rebuildColMarks(marksEl, max){
      if(!marksEl) return;
      marksEl.innerHTML="";
      for(let i=1;i<=max;i++){
        const opt=document.createElement("option");
        opt.value=String(i);
        opt.label=String(i);
        marksEl.appendChild(opt);
      }
    }
    function updateColSliderBounds(max){
      const controls=getColControls();
      const safeMax=Math.max(1, max);
      for(const {slider,marks} of controls){
        slider.max=String(safeMax);
        slider.min="1";
        slider.step="1";
        slider.setAttribute("aria-valuemax", slider.max);
        slider.setAttribute("aria-valuemin", "1");
        if(marks) rebuildColMarks(marks, safeMax);
      }
    }
    function initColsControl(){
      const controls=getColControls();
      if(!controls.length) return;

      const getStoredValue=()=>{
        let val=parseInt(localStorage.getItem(COLS_KEY)||'5',10);
        if(isNaN(val) || val<1) val=5;
        return val;
      };

      const applyWithBounds=(rawValue,{store=true}={})=>{
        const max=computeMaxCols();
        updateColSliderBounds(max);
        let value=typeof rawValue==="number"?rawValue:parseInt(rawValue,10);
        if(isNaN(value)) value=5;
        value=Math.max(1, Math.min(value, Math.max(1,max)));
        if(store) localStorage.setItem(COLS_KEY, String(value));
        applyCols(value);
        return value;
      };

      controls.forEach(({slider})=>{
        slider.addEventListener("input",(e)=>{
          const v=parseInt(e.target.value,10);
          if(isNaN(v)) return;
          applyWithBounds(v);
        });
      });

      let raf=null;
      const onResize=()=>{
        if(raf) cancelAnimationFrame(raf);
        raf=requestAnimationFrame(()=>{ applyWithBounds(getStoredValue(),{store:false}); });
      };

      window.addEventListener("resize", onResize);
      const tabItems=document.getElementById("tabItemsBtn");
      if(tabItems) tabItems.addEventListener("click", onResize);
      const tabConfig=document.getElementById("tabConfigBtn");
      if(tabConfig) tabConfig.addEventListener("click", onResize);

      applyWithBounds(getStoredValue());
    }

    /* ===== Tabs ===== */
    function showTab(which){
      const tabItems=$("#tab-items"), tabConfig=$("#tab-config");
      const tabItemsBtn=$("#tabItemsBtn"), tabConfigBtn=$("#tabConfigBtn");
      if(which==="items"){
        tabItems.classList.remove("hidden"); tabConfig.classList.add("hidden");
        tabItemsBtn.classList.add("active"); tabConfigBtn.classList.remove("active");
        currentTab="items";
      } else {
        tabConfig.classList.remove("hidden"); tabItems.classList.add("hidden");
        tabConfigBtn.classList.add("active"); tabItemsBtn.classList.remove("active");
        currentTab="config";
      }
      renderAll();
    }

    /* ===== Switch 3 fases ===== */
    function initOwnedTri(){
      const tri=$("#ownedTri"); if(!tri) return;

      const legacy = localStorage.getItem(OWNED_KEY_LEGACY);
      if (legacy !== null) {
        state.ownedMode = legacy === "1" ? "yes" : "any";
        localStorage.removeItem(OWNED_KEY_LEGACY);
        localStorage.setItem(OWNED_MODE_KEY, state.ownedMode);
      } else {
        const saved = localStorage.getItem(OWNED_MODE_KEY);
        if (saved==="yes"||saved==="no"||saved==="any") state.ownedMode = saved;
      }

      const modeToVal = (m)=> m==="yes"?0 : m==="any"?1 : 2;
      const valToMode = (v)=> v===0?"yes" : v===1?"any" : "no";

      tri.value = String(modeToVal(state.ownedMode));
      tri.addEventListener("input",(e)=>{
        const v = parseInt(e.target.value,10);
        state.ownedMode = valToMode(isNaN(v)?1:v);
        localStorage.setItem(OWNED_MODE_KEY, state.ownedMode);
        renderAll();
      });

      tri.addEventListener("keydown",(e)=>{
        if(e.key==="ArrowLeft"||e.key==="ArrowRight"){
          const cur = parseInt(tri.value,10);
          const next = Math.max(0, Math.min(2, cur + (e.key==="ArrowRight" ? 1 : -1)));
          if(next!==cur){ tri.value=String(next); tri.dispatchEvent(new Event("input")); }
          e.preventDefault();
        }
      });
    }

    /* ===== Eventos ===== */
    document.getElementById("tabItemsBtn").addEventListener("click", ()=>showTab("items"));
    document.getElementById("tabConfigBtn").addEventListener("click", ()=>showTab("config"));

    document.getElementById("sortMode").addEventListener("change",(e)=>{ state.sortMode=e.target.value; renderAll(); });
    document.getElementById("sortDirBtn").addEventListener("click",()=>{ state.sortDir=(state.sortDir==="asc")?"desc":"asc"; document.getElementById("sortDirBtn").textContent=(state.sortDir==="asc")?"Asc":"Desc"; renderAll(); });

    function setFilter(f){ state.filter=f; document.getElementById("fltAll").classList.toggle("active",f==="all"); document.getElementById("fltWhite").classList.toggle("active",f==="white"); document.getElementById("fltShiny").classList.toggle("active",f==="shiny"); renderAll(); }
    document.getElementById("fltAll").addEventListener("click",()=>setFilter("all"));
    document.getElementById("fltWhite").addEventListener("click",()=>setFilter("white"));
    document.getElementById("fltShiny").addEventListener("click",()=>setFilter("shiny"));

    document.getElementById("btnExport").addEventListener("click", exportProgress);
    document.getElementById("inputProgress").addEventListener("change",(e)=>{ const f=e.target.files?.[0]; if(f) importProgress(f); e.target.value=""; });
    document.getElementById("btnClearProgress").addEventListener("click",()=>{ if(confirm("Tem certeza que deseja limpar o progresso salvo?")) clearProgress(); });
    const btnConfigProgress=document.getElementById("btnConfigProgress");
    if(btnConfigProgress){
      if(nodeFsAdapter){
        btnConfigProgress.textContent="Mostrar local do auto-salvar";
        btnConfigProgress.title="Arquivo de progresso salvo automaticamente ao lado do index.html";
        btnConfigProgress.addEventListener("click",()=>{
          alert(`O progresso esta sendo salvo automaticamente em:\n${nodeFsAdapter.displayName}`);
        });
      }else{
        btnConfigProgress.addEventListener("click", configureProgressFile);
      }
    }

    // Busca
    document.getElementById("searchBox").addEventListener("input",(e)=>{
      state.searchQuery = e.target.value || "";
      renderAll();
    });

    const deleteToggle=document.getElementById("deleteModeToggle");
    if(deleteToggle){
      deleteToggle.addEventListener("change",(e)=>{
        state.deleteMode = !!e.target.checked;
        document.body.classList.toggle("delete-mode", state.deleteMode);
        renderAll();
      });
    }

    /* ===== Inicialização ===== */
    updateProgressFileInfo({});
    loadProgress();
    initColsControl();
    initOwnedTri();
    // tenta restaurar diretório e equip lembrados
    restoreRemembered().then(()=> renderAll());
  </script>
</body>
</html>
